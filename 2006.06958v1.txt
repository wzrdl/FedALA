Understanding the Role of Training Regimes
in Continual Learning
Seyed Iman Mirzadeh
Washington State University, USA
seyediman.mirzadeh@wsu.edu
Mehrdad Farajtabar
DeepMind, USA
farajtabar@google.com
Razvan Pascanu
DeepMind, UK
razp@google.com
Hassan Ghasemzadeh
Washington State University, USA
hassan.ghasemzadeh@wsu.edu
Abstract
Catastrophic forgetting affects the training of neural networks, limiting their ability
to learn multiple tasks sequentially. From the perspective of the well established
plasticity-stability dilemma, neural networks tend to be overly plastic, lacking
the stability necessary to prevent the forgetting of previous knowledge, which
means that as learning progresses, networks tend to forget previously seen tasks.
This phenomenon coined in the continual learning literature, has attracted much
attention lately, and several families of approaches have been proposed with dif-
ferent degrees of success. However, there has been limited prior work extensively
analyzing the impact that different training regimes – learning rate, batch size,
regularization method– can have on forgetting. In this work, we depart from the
typical approach of altering the learning algorithm to improve stability. Instead,
we hypothesize that the geometrical properties of the local minima found for each
task play an important role in the overall degree of forgetting. In particular, we
study the effect of dropout, learning rate decay, and batch size, on forming training
regimes that widen the tasks’ local minima and consequently, on helping it not to
forget catastrophically. Our study provides practical insights to improve stability
via simple yet effective techniques that outperform alternative baselines.1
1 Introduction
We study the continual learning problem, where a neural network model should learn a sequence of
tasks rather than a single one. A signiﬁcant challenge in continual learning (CL) is that during training
on each task, the data from previous ones are unavailable. One consequence of applying typical
learning algorithms under such a scenario is that as the model learns newer tasks, the performance of
the model on older ones degrades. This phenomenon is known as “catastrophic forgetting” [50].
This forgetting problem is closely related to the “stability-plasticity dilemma” [51], which is a
common challenge for both biological and artiﬁcial neural networks. Ideally, a model needs plasticity
to obtain new knowledge and adapt to new environments, while it also requires stability to prevent
forgetting the knowledge from previous environments. If the model is very plastic but not stable,
it can learn fast, but it also forgets quickly. Without further modiﬁcations in training, a naively
trained neural network tends to be plastic but not stable. Note that plasticity in this scenario does not
necessarily imply that neural nets can learn new tasks efﬁciently. In fact, they tend to be extremely
data inefﬁcient. By being plastic, we mean a single update can change the function considerably.
With the recent advances in the deep learning ﬁeld, continual learning has gained more attention
since the catastrophic forgetting problem poses a critical challenge for various applications [41, 35].
A growing body of research has attempted to tackle this problem in recent years [56, 69, 54, 27].
1The code is available at: https://github.com/imirzadeh/stable-continual-learning
Preprint. Under review.
arXiv:2006.06958v1  [cs.LG]  12 Jun 2020
Despite the tangible improvements in the continual learning ﬁeld, the core problem of catas-
trophic forgetting is still under-studied. In particular, a variety of neural network models and
training approaches have been proposed, however, to the best of our knowledge, there has been
little work on systematically understanding the effect of common training regimes created by
varying dropout regularization, batch size, and learning rate on overcoming catastrophic forget-
ting2. Fig. 1 shows how signiﬁcantly these techniques can overcome catastrophic forgetting.
1 2 3 4 5
Tasks Learned
65
70
75
80
85
90
95
100Accuracy
Network 1
dropout=0.5
bs=16
lr=0.25
lr decay=0.4
hiddens=100
Network 2
dropout=0.0
bs=256
lr=0.05
lr decay=1
hiddens=100
Figure 1: For the same architecture
and dataset (Rotation MNIST) and only
changing the training regime, the forget-
ting is reduced signiﬁcantly at the cost
of a relatively small accuracy drop on
the current task. Refer to appendix C for
details.
In this work, we explore the catastrophic forgetting prob-
lem from an optimization and loss landscape perspective
(Section 3) and hypothesize that the geometry of the local
minima found for the different learned tasks correlates
with the ability of the model to not catastrophically forget.
Empirically we show how a few well-known techniques,
such as dropout and large learning rate with decay and
shrinking batch size, can create a training regime to af-
fect the stability of neural networks (Section 4). Some
of them, like dropout, had been previously proposed to
help continual learning [20, 52]. However, in this work,
we provide an alternative justiﬁcation of why these tech-
niques are effective. Crucially, we empirically show that
jointly with a carefully tuned learning rate schedule and
batch size, these simple techniques can outperform con-
siderably more complex algorithms meant to deal with
continual learning (Section 5). Our analysis can be ap-
plied to any other training technique that widens the tasks’
local minima or shrinks the distance between them.
2 Related work
Several continual learning methods have been proposed to tackle catastrophic forgetting. Following
[41], we categorize these algorithms into three general groups.
The ﬁrst group consists of replay based methods that build and store a memory of the knowledge
learned from old tasks [ 46, 59, 78, 65, 60], known as experience replay. iCaRL [ 58] learns in a
class-incremental way by having a ﬁxed memory that stores samples that are close to the center of
each class. Averaged Gradient Episodic Memory (A-GEM) [6] is another example of these methods
which build a dynamic episodic memory of parameter gradients during the learning process while
ER-Reservoir [8] uses a Reservoir sampling method as its selection strategy.
The methods in the second group use explicit regularization techniques to supervise the learning
algorithm such that the network parameters are consistent during the learning process [39, 76, 42, 1,
40]. As a notable work, Elastic weight consolidation (EWC) [39], uses the Fisher information matrix
as a proxy for weights’ importance and guides the gradient updates. They are usually inspired by a
Bayesian perspective [53, 68, 64, 12, 61]. With a frequentist view, some other regularization based
methods have utilized gradient information to protect previous knowledge [13, 22, 75]. For example,
Orthogonal Gradient Descent (OGD) [13] uses the projection of the prediction gradients from new
tasks on the subspace of previous tasks’ gradients to maintain the learned knowledge.
Finally, in parameter isolation methods, in addition to potentially a shared part, different subsets of
the model parameters are dedicated to each task [62, 74, 33, 57, 44]. This approach can be viewed
as a ﬂexible gating mechanism, which enhances stability and controls the plasticity by activating
different gates for each task. [48] proposes a neuroscience-inspired method for a context-dependent
gating signal, such that only sparse, mostly non-overlapping patterns of units are active for any one
task. PackNet [47] implements a controlled version of gating by using network pruning techniques to
free up parameters after ﬁnishing each task.
While continual learning is broader than just solving the catastrophic forgetting, in this work we
will squarely focus on catastrophic forgetting, which has been an important aspect, if not the most
2Potential exceptions being the early work of Goodefellow et. al [20] and a recent one by Mirzadeh et. al [52]
2
important one, of research for Continual Learning in the last few years. Continual Learning as an
emerging ﬁeld in Artiﬁcial Intelligence is connected to many other areas such as Meta Learning [4,
33, 22, 59], Few Shot Learning [ 71, 19], Multi-task and Transfer Learning [22, 33] and the closely
related problem of exploring task boundary or task detection [57, 2, 23, 34].
3 Forgetting during training
Let us begin this section by introducing some notation to express the effect of forgetting during the
sequential learning of tasks. For simplicity, let us consider the supervised learning case, which will
be the focus of this work. We consider a sequence ofK tasksTk fork∈{ 1, 2,...,K }. LetW∈ Rd
be the parameter space for our model. The total loss on the training set (empirical risk) for taskk is
denoted by
Lk(w) = E[ℓk(w;x,y )]≈ 1
|Tk|
∑
(x,y)∈Tk
,ℓ k(w;x,y ) (1)
where, the expectation is over the data distribution of taskk andℓk is a differentiable non-negative
loss function associated with data point (x,y ) for taskk. In the continual learning setting, the model
learns sequentially, without access to examples of previously seen tasks. For simplicity and brevity,
let us focus on measuring the forgetting in continual learning with two tasks. It is easy to extend
these ﬁndings to more tasks.
Letw∗
1 andw∗
2 be the convergent or optimum parameters after training has been ﬁnished for the ﬁrst
and second task sequentially. We formally deﬁne theforgetting (of the ﬁrst task) as:
F1 ≜L1(w∗
2)−L1(w∗
1). (2)
We hypothesize thatF1 strongly correlates with properties of the curvature ofL1 aroundw∗
1 andL2
aroundw∗
2. In what follows, we will formalize this hypothesis.
One important assumption that we rely on throughout this section is that we can use a second-
order Taylor expansion of our losses to understand the learning dynamics during the training of
the model. While this might seem as a crude approximation in general — for a nonlinear function
and non-inﬁnitesimal displacement this approximation can be arbitrarily bad — we argue that the
approximation has merit for our setting. In particular, we rely on the wealth of observations for
overparametrized models where the loss tends to be very well behaved and almost convex in a
reasonable neighborhood around their local minima. E.g. for deep linear models this property
has been studied in [ 63]. Works as [ 10, 21] make similar claims for generic models. [ 29] also
corroborates that within the NTK regime learning is well behaved. In continual learning, similar
strong assumptions are made by most approaches that rely on approximating the posterior on the
weights by a Gaussian [39] or a ﬁrst-order approximation of the loss surface around the optimum [13].
Armed with this analytical tool, to compute the forgetting, we can approximateL1(w∗
2) aroundw∗
1:
L1(w∗
2)≈L1(w∗
1) + (w∗
2−w∗
1)⊤∇L1(w∗
1) + 1
2(w∗
2−w∗
1)⊤∇2L1(w∗
1)(w∗
2−w∗
1) (3)
≈L1(w∗
1) + 1
2(w∗
2−w∗
1)⊤∇2L1(w∗
1)(w∗
2−w∗
1), (4)
where,∇2L1(w∗
1) is the Hessian for lossL1 atw∗
1 and the last equality holds because the model is
assumed to converge to a stationary point where gradient’s norm vanishes, thus∇L1(w∗
1)≈ 0.
Under the assumption that the critical point is a minima (or the plateau we get stuck in surrounds a
minima), we know that the Hessian needs to be positive semi-deﬁnite. Deﬁning∆w =w∗
2−w∗
1 as
the relocation vector, we can bound the forgettingF1 as follows:
F1 =L1(w∗
2)−L1(w∗
1)≈ 1
2∆w⊤∇2L1(w∗
1)∆w≤ 1
2λmax
1 ∥∆w∥2, (5)
whereλmax
1 is the maximum eigenvalue of∇2L1(w∗
1). Fig. 2a shows how widerL1 (lowerλmax
1 )
leads to less forgetting, both in terms of an illustrative example as well as showing empirical evidence
for this relationship on Rotated MNIST and Permuted MNIST.
A few notes on this bound. First, the bound is achieved when ∆w is co-aligned to the eigenvector
corresponding toλ1. Given that the displacement is generated by the learning process on task 2, we
3
w∗
1 w∗
2
Parameter Space
Loss
F1
F′
1
∆w
L1(w) = λ1 (w − w∗
1)2
L′
1(w) = 2λ1 (w − w∗
1)2
L2(w) = λ2 (w − w∗
2)2
(a)
w∗
1 w∗
2
Parameter Space
ϵ Loss
F1
∆w
F′
1
L1(w) = λ1 (w − w∗
1)2
L2(w) = λ2 (w − w∗
2)2
L′
2(w) = 2λ2 (w − w∗
2)2 (b)
0.0 0.5 1.0
λ(1)
max ∥∆w∥2 (×10−2)
0.0
0.5
1.0
1.5
Forgeting (F1)
 (c)
0.0 0.5 1.0
λ(1)
max ∥∆w∥2 (×10−2)
0.0
2.5
5.0
7.5
Forgeting (F1)
 (d)
Figure 2: (a): For a ﬁxed∆w, the wider the curvature of the ﬁrst task, the less the forgetting. (b):
The wider the curvature of the second task, the smaller∥∆w∥. (c) and (d): Empirical veriﬁcation of
(5) for Rotated MNIST and Permuted MNIST, respectively.
can think of it as a random vector with respect to the eigenvectors of the Hessian of the ﬁrst task.
We know, therefore, that the tightness of the bound correlates with the dimensionality ofw. In the
extreme one-dimensional case, the Hessian matrix becomes a scalar given byλmax
1 , and the bound is
exact. As we increase the number of dimensions, the probability of two vectors to be perpendicular
goes to 1. Hence in high-dimensional spaces is more likely for the bound to be relatively loose and
for the entire spectrum of eigenvalues to play a much more important role in deﬁningF1. Namely,
as the number of eigenvalues with low magnitude increases, the more likely it is forF1 to be small.
Assuming that the displacement vector is equally distributed over all the eigenvectors, then the trace
of the Hessian will correlate stronger with F1 than the largest eigenvalue. However, reasoning in
terms of the spectrum can be impractical (note, for example, that one can not trivially re-write the
bound in terms of the trace). So we believe it is useful to think about λmax
1 as long as any conclusion
is contextualized correctly and the training regime we consider, implicitly, is aimed at lowering the
entire spectrum, not just the largest eigenvalue.
We also want to highlightλmax
1 has been used previously to describe the width of a local minima [26,
37], with similar notes regarding the role of the entire spectrum [11, 37]. This property is central to
the wide/narrow minima hypothesis for why neural networks generalize well. Our hypothesis is not
tight to the generalization of wide minima, but we rely on the same or at least a very related concept
of width. Therefore, to reduce forgetting, each task should push its learning towards wider minima
and can employ the same techniques used to widen the minima to improve generalization.
Resuming from Eq. 5, controlling the Hessian spectrum without controlling the norm of the displace-
ment, however, might not ensure thatF1 is minimized.
Table 1: Disentangling the for-
getting on Permuted MNIST.
Details are left to appendix C.
Task 1 Task 2 Forgetting
(F1)
Stable Stable 1.61 ±(0.48)
Stable Plastic 4.77 ±(1.72)
Plastic Stable 12.45 ±(1.58)
Plastic Plastic 19.37±(1.79) )
∥∆w∥ is technically controlled by the subsequent tasks. We ﬁrst
notice, empirically, that enforcing widening the minima of the next
task (for the same reason of reducing forgetting on itself) inhibits
additionally forgetting for the ﬁrst task (see Table 1; not stable/plastic
means relying on training regimes that encourage/do not encourage
wide minima. We empirically estimate the width of minima as well,
see appendix C for details). We make the observation that the width
of the minima (norm of the eigenvalues) correlates with the norm of
the weights. Hence the solutions in the stable learning regime tend
to be closer to 0, which automatically decrease∥∆w∥.
Additionally,∥∆w∥ relates to λmax
2 also due to typical learning
terminating near a minima, rather than at the minima. Refer to ﬁg. 2b for an illustration. Speciﬁcally,
the convergence criterion is usually satisﬁed in theϵ-neighborhood ofw∗
2. If we write the second
order Taylor approximation ofL2 aroundw∗
2, we get:
L2( ˆw2)−L2(w∗
2)≈ 1
2( ˆw2−w∗
2)⊤∇2L2( ˆw2)( ˆw2−w∗
2)≤ 1
2λmax
2 ∥w∗
2− ˆw2∥2≤ϵ, (6)
where, the ﬁrst equality holds since∇L2(w∗
2) = 0. Thus, by decreasing λmax
2 , ˆw2 can be reached
further fromw∗
2 since theϵ-neighborhood is larger, and closer tow∗
1. A more formal analysis is given
in the appendix. Note that as we enforce the error on task 2 to be lower, the argument above weakens.
In the limit, if we assume you converged on task 2, the distance does not depend on curvature, just
∥w∗
1−w∗
2∥. However, the choice of which minimaw∗
2 learning prefers will still affect the distance,
4
and as argued above, if wider minima tend to be closer to 0, then they tend to be closer to each other
too. Collating all of these observations together we propose the following hypothesis:
Hypothesis. The amount of forgetting that a neural network exhibits from learning the tasks sequen-
tially, correlates with the geometrical properties of the convergent points. In particular, the wider
these minima are, the less forgetting happens.
We empirically verify the relationship between forgetting and the upper bound derived in E.q.(5). We
approximate the Hessian with the largest eigenvalue of the loss function. The results in two common
continual learning benchmarks is shown in Figures 2c and 2d. In the ﬁgure, the dots represent
different neural network training regimes with different settings (e.g., with and without dropout, with
and without learning rate decay, different initial learning rates, different batch sizes, different random
initialization). See section 4 to ﬁnd out how these techniques can lead to different loss geometries.
All of the models have roughly 90% accuracy on task 2. We can see that our derived measure has
high correlation with the forgetting.
4 Training Regimes: techniques affecting stability and forgetting
In this section, we describe a set of widely used techniques that are known to affect the width of
the minima (eigenspectrum of Hessian) as well as the length of the path taken by learning (∥∆w∥).
These observations had been generally made with respect to improving generalization, following the
wide/narrow minima hypothesis. Based on the argumentation of the previous section, we believe
these techniques can have an important role in affecting forgetting as well. In the following section,
we will validate this through solid empirical evidence that agrees with our stated hypothesis.
4.1 Optimization setting: learning rate, batch size, and optimizer
There has been a large body of prior work studying the relationship between the learning rate, batch
size, and generalization. One common technique of analysis in this direction is to measure the
largest eigenvalues of the Hessian of the loss function, which quantiﬁes the local curvature around
minima [37, 15, 31, 30, 31]. Followed by the work by Keskar et al. [37], several other papers studied
the correlation between minima wideness and generalization [30, 49, 31].
The learning rate and batch size inﬂuence both the endpoint curvature and the whole trajectory [ 73,
16, 43]. A high learning rate or a small batch size limits the maximum spectral norm along the path
found by SGD from the beginning of training [31]. This is further studied by Jastrzebski et al. [32],
showing that using a large learning rate in the initial phase of training reduces the variance of the
gradient, and improves the conditioning of the covariance of gradients which itself is close to the
Hessian in terms of the largest eigenvalues [77].
Although having a higher learning rate tends to be helpful since it increases the probability of
converging to a wider minima [32], considering a continual optimization problem, we can see it has
another consequence: it contributes to the rate of change (i.e., ∆w in (5)). Using a higher learning
rate means applying a higher update to the neural network weights. Therefore, since the objective
function changes thorough time, having a high learning rate is a double-edged sword. Intuitively
speaking, decreasing the learning rate across tasks prevents the parameters from going far from the
current optimum, which helps reduce forgetting. One natural solution could be to start with a high
initial learning rate for the ﬁrst task to obtain a wide and stable minima. Then, for each subsequent
task, slightly decrease the learning rate but also decrease the batch-size instead, as suggested in [66].
Regarding the choice of an optimizer, we argue for the effectiveness of SGD in continual learning
setting compared to adaptive optimizers. Although the adaptive gradient methods such as Adam [38]
tend to perform well in the initial phase of training, they are outperformed by SGD at later stages
of training due to generalization issues [36, 9]. Wilson et al. [72] show that even for a toy quadratic
problem, Adam generalizes provably worse than SGD. Moreover, Ge et al.[18] study the effectiveness
of exponentially decaying learning rate and show that in its ﬁnal iterate, it can achieve a near-optimal
error in stochastic optimization problems.
Connection to continual learning. The effect of learning rate and batch-size has not been directly
studied in the context of continual learning, to the extent of our knowledge. However, we ﬁnd
that the reported hyper-parameters in several works match our ﬁndings. Using a small batch size
is very common across the continual learning methods. OGD [ 13] uses a small batch size of 10,
5
similar to several other works [8, 6, 7]. EWC [39] uses a batch size of 32 and also the learning rate
decay of 0.95. iCaRL [58] starts from a large learning rate and decays the learning at certain epochs
exponentially by a factor of 0.2, while it uses a larger batch size of 128. Finally, PackNet [47] also
reports using a learning rate decay by a factor of 0.1. When it comes to choosing the optimizer,
the literature mostly prefers SGD with momentum over the adaptive gradient methods. With the
exception of VCL [53], which uses Adam, several other algorithms such as A-GEM, OGD, EWC,
iCaRL, and PackNet use the standard SGD.
4.2 Regularization: dropout and weight decay
We relate the theoretical insights on dropout andL2 regularization (weight decay) to our analysis in
the previous section. We ﬁrst argue for the effectiveness of dropout, and then we discuss whyL2
regularization might hurt the performance in a continual learning setting.
Dropout [25] is a well-established technique in deep learning, which is also well-studied theoretically
[3, 67, 24, 17, 70]. Wei et al. [70] showed that dropout has both implicit and explicit but entangled
regularization effects: More speciﬁcally, they provided an approximation for the explicit effect on
the i-th hidden layer (denoted by hi) under input x by: (p/p−1)[∇2
hiL]T [diag(h2
i )], where p is
the dropout probability,L is the loss function, and diag(v) is a diagonal matrix of vector v. This
term encourages the ﬂatness of the minima since it minimizes the second derivative of the loss with
respect to the hidden activation (that is tightly correlated with the curvature with respect to weights).
Thus, dropout regularization reduces the R.H.S of Eq. (5). Note that by regularizing the activations
norm, it also pushes down the norm of the weights, hence encouraging to ﬁnd a minima close to 0,
which in turn could reduce the norm of ∆w. Intuitively, we can understand this effect also from the
tendency of dropout to create redundant features. This will reduce the effective number of dimensions
of the representation, increasing the number of small-magnitude eigenvalues for the Hessian. As
a consequence, gradient updates of the new tasks are less likely to lie on the space spanned by
signiﬁcant eigendirections of previous losses, which results in lesser forgetting.
With respect toL2 regularization, while intuitively it should help, we make two observations. First,
dropout is data-dependent, whileL2 is not. That means balancing the effect of regularization with
learning is harder, and in practice, it seems to work worse (both for the currently learned task and
for reducing forgetting while maintaining good performance on the new task). Secondly, when
combined with Batch Normalization [28],L2 regularization leads to an Exponential Learning Rate
Schedule [45], meaning that in each iteration, multiplying the initial learning rate by (1 +α) for
someα> 0 that depends on the momentum and weight decay rate. Hence, usingL2 regularization is
equivalent to increasing the learning rate overall, potentially leading to larger displacements ∆w.
Connection to continual learning. To the best of our knowledge, the work by Goodfellow et al.
[20] is the ﬁrst to empirically study the importance of the dropout technique in the continual learning
setting. They hypothesize that dropout increases the optimal size of the network by regularizing and
constraining the capacity to be just barely sufﬁcient to perform the ﬁrst task. However, by observing
some inconsistent results on dissimilar tasks, they suggested dropout may have other beneﬁcial effects
too. Very recently, [52] studied the effectiveness of dropout for continual learning from the gating
perspective. Our work extends their analysis in a more general setting by studying the regularization
effect of dropout and its connection to loss landscape. Finally, [ 41] conducted a comprehensive
empirical study on the effect of weight decay and dropout on the continual learning performance and
reported that the model consistently beneﬁts from dropout regularization as opposed to weight decay
which results in increased forgetting and lower performance on the ﬁnal model.
5 Experiments and results
In this section, after explaining our experimental setup, we show the relationship between the
curvature of the loss function and the amount of forgetting. We use the terms Stable and Plastic
(Naive) to distinguish two different training regimes. The stable network (or stable SGD) exploits the
dropout regularization, large initial learning rate with exponential decay schedule at the end of each
task, and small batch size, as explained in Sec. 4. In contrast, the plastic (naive) SGD model does not
exploit these techniques. In the second experiment, we challenge the stable network and compare it
to various state of the art methods on a large number of tasks and more difﬁcult benchmarks.
6
5.1 Experimental setup
Here, we discuss our experimental methodologies. The decisions regarding the datasets, network
architectures, continual learning setup (e.g., number of tasks, training epochs per task), hyper-
parameters, and evaluation metrics are chosen to be consistent with several other studies [6, 8, 7, 13],
making it easy to compare our results. For all experiments, we report the average and standard
deviation over ﬁve runs, each with a different random seed. For brevity, we include the detailed
hyper-parameters, the code, and instructions for reproducing the results in the supplementary ﬁle.
Datasets. We perform our experiments on three standard continual learning benchmarks: Permuted
MNIST [20], Rotated MNIST, and Split CIFAR-100. While we agree with [ 14] regarding the
drawbacks of Permuted MNIST in continual learning settings, we believe for consistency with other
studies, it is essential to report the results on this dataset as well. Moreover, we report our results
on Rotated MNIST and CIFAR-100 that are more challenging and realistic datasets for continual
learning benchmarks, once the number of tasks is large. Each task of permuted MNIST is generated
by random shufﬂing of the pixels of images such that the permutation is the same for the images
of the same task, but different across different tasks. Rotated MNIST is generated by the continual
rotation of the MNIST images where each task applies a ﬁxed random image rotation (between 0 and
180 degrees) to the original dataset. Split CIFAR-100 is a variant of the CIFAR-100 where each task
contains the data from 5 random classes (without replacement) out of the total 100 classes.
Models. In our ﬁrst experiment (Sec. 5.2), we evaluate the continual learning performance over
ﬁve sequential tasks to provide ﬁne-grained metrics for each task. For this experiment, we use a
feed-forward neural network with two hidden layers, each with 100 ReLU neurons and use the
deﬂated power iteration for computing eigenvalues [55]. For the second experiment (Sec. 5.3), we
scale the experiments to 20 tasks and use a two-layer network with 256 ReLU neurons in each layer
for MNIST datasets, and a ResNet18, with three times fewer feature maps across all layers for CIFAR
experiments. These architectures have been previously chosen in several studies [6, 8, 13, 7].
Evaluation. We use two metrics from [5, 6, 8] to evaluate continual learning algorithms when the
number of tasks is large.
(1) Average Accuracy: The average validation accuracy after the model has been trained sequentially
up to taskt, deﬁned by:
At = 1
t
t∑
i=1
at,i (7)
where,at,i is the validation accuracy on dataseti when the model ﬁnished learning taskt.
(2) Average Forgetting: The average forgetting after the model has been trained sequentially on all
tasks. Forgetting is deﬁned as the decrease in performance at each of the tasks between their peak
accuracy and their accuracy after the continual learning experience has ﬁnished. For a continual
learning dataset withT sequential tasks, it is deﬁned by:
F = 1
T− 1
T−1∑
i=1
maxt∈{1,...,T−1} (at,i−aT,i) (8)
5.2 Stable versus Plastic networks
Here, we verify the signiﬁcance of the training regime in continual learning performance (Sec 3.) and
demonstrate the effectiveness of the stability techniques (Sec 4.) in reducing the forgetting.
Each row of Figure 3, represents one of three related concepts for each training regime on each dataset.
First, the top row shows the evolution of accuracy on validation sets of each task during the continual
learning experience. For instance, the blue lines in this row show the validation accuracy of task 1
throughout the learning experience. In the Middle row, we show the twenty sharpest eigenvalues of
the curvatures of each task. In the bottom row, we measure theℓ2 distance of network parameters
between the parameters learned for each task, and the parameters learned for subsequent tasks.
Aligned with our analysis in Section 3, we show that in contrast to plastic regime, the stable training
reduces the catastrophic forgetting (Fig. 3 (Top)) thanks to (1) decreasing the curvature (Fig. 3
(Middle)) and (2) shrinking the change of parameters (Fig. 3 (Bottom)).
7
1 2 3 4 5
Tasks
50
60
70
80
90
100Accuracy
Task 1
Task 2
Task 3
Task 4
Task 5
1 2 3 4 5
Tasks
50
60
70
80
90
100Accuracy
Task 1
Task 2
Task 3
Task 4
Task 5
1 2 3 4 5
Tasks
50
60
70
80
90
100Accuracy
Task 1
Task 2
Task 3
Task 4
Task 5
1 2 3 4 5
Tasks
50
60
70
80
90
100Accuracy
Task 1
Task 2
Task 3
Task 4
Task 5
1 5 10 15 20
Eigenvalue Index
0
2
4
6
8
10
12Eigenvalue
Task 1
Task 2
Task 3
Task 4
Task 5
1 5 10 15 20
Eigenvalue Index
0
2
4
6
8
10
12Eigenvalue
Task 1
Task 2
Task 3
Task 4
Task 5
1 5 10 15 20
Eigenvalue Index
0
2
4
6
8
10
12Eigenvalue
Task 1
Task 2
Task 3
Task 4
Task 5
1 5 10 15 20
Eigenvalue Index
0
2
4
6
8
10
12Eigenvalue
Task 1
Task 2
Task 3
Task 4
Task 5
1 2 3 4 5
Tasks
250
500
750
1000∥∆w∥
Task 1
Task 2
Task 3
Task 4
(a) Permuted - Stable
1 2 3 4 5
Tasks
250
500
750
1000∥∆w∥
Task 1
Task 2
Task 3
Task 4 (b) Permuted - Plastic
1 2 3 4 5
Tasks
250
500
750
1000∥∆w∥
Task 1
Task 2
Task 3
Task 4 (c) Rotated - Stable
1 2 3 4 5
Tasks
250
500
750
1000∥∆w∥
Task 1
Task 2
Task 3
Task 4 (d) Rotated - Plastic
Figure 3: Comparison of training regimes for MNIST datasets: (Top) Evolution of validation
accuracy for each task : stable networks suffer less from catastrophic forgetting. (Middle) The
spectrum of the Hessian for each task: the eigenvalues in stable networks are signiﬁcantly smaller.
(Bottom) The degree of parameter change: in stable networks,the parameters remain closer to the
their initial values after learning each task.
5.3 Comparison with other methods
In this experiment, we show that the stable network is a strong competitor for various continual
learning algorithms. In this scaled experiment, we increase the number of tasks from 5 to 20,
and provide results for Split CIFAR-100, which is a challenging benchmark for continual learning
algorithms. The episodic memory size for A-GEM and ER-Reservoir is limited to be one example per
class per task (i.e., 200 examples for MNIST experiments and 100 for CIFAR-100), similar to [8, 7].
To have a consistent naming with other studies, in this section, we use the word “Naive” to describe
a plastic network in our paper. To evaluate each algorithm, we measure the average accuracy and
forgetting (i.e.,At andF in Sec. 5.1).
Table 2 compares these metrics for each method once the continual learning experience is ﬁnished
(i.e., after learning task 20). Moreover, Fig. 4 provides a more detailed picture of the average accuracy
during the continual learning experience. To show that stable networks suffer less from catastrophic
forgetting, we provide a comparison of the ﬁrst task’s accuracy in the appendix.
While our stable network performs consistently better than other algorithms, we note that our proposed
techniques are orthogonal to other works and can also be incorporated in them.
Table 2: Comparison of the average accuracy and forgetting of several methods on three datasets.
Method Memoryless Permuted MNIST Rotated MNIST Split CIFAR100
Accuracy Forgetting Accuracy Forgetting Accuracy Forgetting
Naive SGD  44.4 (±2.46) 0.53 (±0.03) 46.3 (±1.37) 0.52 (±0.01) 40.4 (±2.83) 0.31 (±0.02)
EWC  70.7 (±1.74) 0.23 (±0.01) 48.5 (±1.24) 0.48 (±0.01) 42.7 (±1.89) 0.28 (±0.03)
A-GEM  65.7 (±0.51) 0.29 (±0.01) 55.3 (±1.47) 0.42 (±0.01) 50.7 (±2.32) 0.19 (±0.04)
ER-Reservoir  72.4 (±0.42) 0.16 (±0.01) 69.2 (±1.10) 0.21 (±0.01) 46.9 (±0.76) 0.21 (±0.03)
Stable SGD  80.1 (±0.51) 0.09 (±0.01) 70.8 (±0.78) 0.10 (±0.02) 59.9 (±1.81) 0.08 (±0.01)
Multi-Task Learning N/A 86.5 ( ±0.21) 0.0 87.3( ±0.47) 0.0 64.8( ±0.72) 0.0
8
1 5 10 15 20
Tasks
40
50
60
70
80
90
100Accuracy
STABLE
AGEM
ER
EWC
Naive
(a) Permuted MNIST
1 5 10 15 20
Tasks
40
50
60
70
80
100Accuracy
STABLE
AGEM
ER
EWC
Naive (b) Rotated MNIST
1 5 10 15 20
Tasks
35
40
50
60
70Accuracy
STABLE
AGEM
ER
EWC
Naive (c) Split CIFAR-100
Figure 4: Evolution of the average accuracy during the continual learning
6 Conclusion
In this work, we revisit the catastrophic forgetting problem from loss landscapes and optimization
perspective and identify learning regimes and training techniques that contribute to the forgetting.
The analytical insights yielded a series of effective and practical techniques that can reduce forgetting
and increase the stability of neural networks in maintaining previous knowledge.
We analyzed these techniques through the lens of optimization by studied the wideness of the
loss surfaces around the local minima. However, they might have other confounding factors for
reducing catastrophic forgetting as well. We call for more theoretical research to further their role in
demystifying trading off the stability plasticity dilemma and its effect on continual learning.
Finally, we have empirically observed that these simple techniques proved to be more effective than
some of the recent approaches (e.g., regularization based methods, or memory-based methods) but
are orthogonal to them in the sense that our practical recommendations and provided insights on loss
perspective can be incorporated to them. This is left as a very interesting future work.
Broader Impact
Continual Learning aims for effectively training a model from sequential tasks while making sure the
model maintains a reasonable performance on the previous ones. It’s an integral part of Artiﬁcial
General Intelligence (AGI) that reduces the cost of retraining (time, computation, resources, energy)
and mitigates the need for storing all previous data to respect users’ privacy concerns better. Reducing
catastrophic forgetting may potentially risk privacy for data that are explicitly wanted to be forgotten.
This calls for more future research into formalizing and proposing continual learning agents that
allow the identiﬁable parts of data to be forgotten, but the general knowledge is maintained. The
research presented in this paper can be used for many different application areas and a particular use
may have both positive or negative implications. Besides those, we are not aware of any immediate
short term negative impact.
Acknowledgment
The authors thank Jonathan Schwarz, Sepehr Sameni, Hooman Shahrokhi, and Mohammad Sadegh
Jazayeri for their valuable comments and feedback.
References
[1] Rahaf Aljundi, Francesca Babiloni, Mohamed Elhoseiny, Marcus Rohrbach, and Tinne Tuytelaars. Memory
aware synapses: Learning what (not) to forget. In Proceedings of the European Conference on Computer
Vision (ECCV), pages 139–154, 2018.
[2] Rahaf Aljundi, Min Lin, Baptiste Goujaud, and Yoshua Bengio. Online continual learning with no task
boundaries. arXiv preprint arXiv:1903.08671, 2019.
[3] Pierre Baldi and Peter J Sadowski. Understanding dropout. In C. J. C. Burges, L. Bottou, M. Welling,
Z. Ghahramani, and K. Q. Weinberger, editors,Advances in Neural Information Processing Systems 26,
pages 2814–2822. Curran Associates, Inc., 2013.
9
[4] Shawn Beaulieu, Lapo Frati, Thomas Miconi, Joel Lehman, Kenneth O Stanley, Jeff Clune, and Nick
Cheney. Learning to continually learn. arXiv preprint arXiv:2002.09571, 2020.
[5] Arslan Chaudhry, Puneet Kumar Dokania, Thalaiyasingam Ajanthan, and Philip H. S. Torr. Riemannian
walk for incremental learning: Understanding forgetting and intransigence. In ECCV, 2018.
[6] Arslan Chaudhry, Marc’Aurelio Ranzato, Marcus Rohrbach, and Mohamed Elhoseiny. Efﬁcient lifelong
learning with a-gem. ArXiv, abs/1812.00420, 2018.
[7] Arslan Chaudhry, Albert Gordo, Puneet Kumar Dokania, Philip H. S. Torr, and David Lopez-Paz. Using
hindsight to anchor past knowledge in continual learning. ArXiv, abs/2002.08165, 2019.
[8] Arslan Chaudhry, Marcus Rohrbach, Mohamed Elhoseiny, Thalaiyasingam Ajanthan, Puneet K. Dokania,
Philip H. S. Torr, and Marc’Aurelio Ranzato. On tiny episodic memories in continual learning. 2019.
[9] Jinghui Chen and Quanquan Gu. Closing the generalization gap of adaptive gradient methods in training
deep neural networks. ArXiv, abs/1806.06763, 2018.
[10] Anna Choromanska, Mikael Henaff, Michael Mathieu, Gérard Ben Arous, and Yann LeCun. The loss
surfaces of multilayer networks. In Artiﬁcial intelligence and statistics, pages 192–204, 2015.
[11] Laurent Dinh, Razvan Pascanu, Samy Bengio, and Yoshua Bengio. Sharp minima can generalize for
deep nets. In Proceedings of the 34th International Conference on Machine Learning-Volume 70, pages
1019–1028. JMLR. org, 2017.
[12] Sayna Ebrahimi, Mohamed Elhoseiny, Trevor Darrell, and Marcus Rohrbach. Uncertainty-guided continual
learning with bayesian neural networks. arXiv preprint arXiv:1906.02425, 2019.
[13] Mehrdad Farajtabar, Navid Azizan, Alex Mott, and Ang Li. Orthogonal gradient descent for continual
learning. ArXiv, abs/1910.07104, 2019.
[14] Sebastian Farquhar and Yarin Gal. Towards robust evaluations of continual learning.ArXiv, abs/1805.09733,
2018.
[15] Stanislav Fort and Surya Ganguli. Emergent properties of the local geometry of neural loss landscapes.
ArXiv, abs/1910.05929, 2019.
[16] Jonathan Frankle, David J. Schwab, and Ari S. Morcos. The early phase of neural network training. In
ICLR 2020 : Eighth International Conference on Learning Representations, 2020.
[17] Hongchang Gao, Jian Pei, and Heng Huang. Demystifying dropout. In ICML, 2019.
[18] Rong Ge, Sham M. Kakade, Rahul Kidambi, and Praneeth Netrapalli. The step decay schedule: A near
optimal, geometrically decaying learning rate procedure. ArXiv, abs/1904.12838, 2019.
[19] Spyros Gidaris and Nikos Komodakis. Dynamic few-shot visual learning without forgetting. InProceedings
of the IEEE Conference on Computer Vision and Pattern Recognition, pages 4367–4375, 2018.
[20] Ian J. Goodfellow, Mehdi Mirza, Xia Da, Aaron C. Courville, and Yoshua Bengio. An empirical investiga-
tion of catastrophic forgeting in gradient-based neural networks. CoRR, abs/1312.6211, 2013.
[21] Ian J Goodfellow, Oriol Vinyals, and Andrew M Saxe. Qualitatively characterizing neural network
optimization problems. arXiv preprint arXiv:1412.6544, 2014.
[22] Xu He and Herbert Jaeger. Overcoming catastrophic interference using conceptor-aided backpropagation.
In ICLR 2018, 2018.
[23] Xu He, Jakub Sygnowski, Alexandre Galashov, Andrei A Rusu, Yee Whye Teh, and Razvan Pascanu. Task
agnostic continual learning via meta learning. arXiv preprint arXiv:1906.05201, 2019.
[24] David P. Helmbold and Philip M. Long. Surprising properties of dropout in deep networks. J. Mach. Learn.
Res., 18:200:1–200:28, 2016.
[25] Geoffrey E. Hinton, Nitish Srivastava, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. Im-
proving neural networks by preventing co-adaptation of feature detectors. ArXiv, abs/1207.0580, 2012.
[26] Sepp Hochreiter and Jürgen Schmidhuber. Flat minima. Neural Computation, 9(1):1–42, 1997.
[27] Yen-Chang Hsu, Yen-Cheng Liu, and Zsolt Kira. Re-evaluating continual learning scenarios: A categoriza-
tion and case for strong baselines. arXiv preprint arXiv:1810.12488, 2018.
10
[28] Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by reducing
internal covariate shift. ArXiv, abs/1502.03167, 2015.
[29] Arthur Jacot, Franck Gabriel, and Clément Hongler. Neural tangent kernel: Convergence and generalization
in neural networks. In Advances in neural information processing systems, pages 8571–8580, 2018.
[30] Stanislaw Jastrzebski, Zachary Kenton, Devansh Arpit, Nicolas Ballas, Asja Fischer, Yoshua Bengio, and
Amos J. Storkey. Three factors inﬂuencing minima in sgd. ArXiv, abs/1711.04623, 2018.
[31] Stanislaw Jastrzebski, Zachary Kenton, Nicolas Ballas, Asja Fischer, Yoshua Bengio, and Amos J. Storkey.
On the relation between the sharpest directions of dnn loss and the sgd step length. In ICLR, 2018.
[32] Stanislaw Jastrzebski, Maciej Szymczak, Stanislav Fort, Devansh Arpit, Jacek Tabor, Kyunghyun Cho, and
Krzysztof Geras. The break-even point on the optimization trajectories of deep neural networks. In ICLR
2020 : Eighth International Conference on Learning Representations, 2020.
[33] Ghassen Jerfel, Erin Grant, Thomas L. Grifﬁths, and Katherine A. Heller. Reconciling meta-learning and
continual learning with online mixtures of tasks. In NeurIPS, 2019.
[34] Christos Kaplanis, Murray Shanahan, and Claudia Clopath. Policy consolidation for continual reinforce-
ment learning. arXiv preprint arXiv:1902.00255, 2019.
[35] Ronald Kemker, Marc McClure, Angelina Abitino, Tyler L Hayes, and Christopher Kanan. Measuring
catastrophic forgetting in neural networks. In Thirty-second AAAI conference on artiﬁcial intelligence,
2018.
[36] Nitish Shirish Keskar and Richard Socher. Improving generalization performance by switching from adam
to sgd. ArXiv, abs/1712.07628, 2017.
[37] Nitish Shirish Keskar, Dheevatsa Mudigere, Jorge Nocedal, Mikhail Smelyanskiy, and Ping Tak Peter
Tang. On large-batch training for deep learning: Generalization gap and sharp minima. In ICLR 2017 :
International Conference on Learning Representations 2017, 2017.
[38] Diederik P. Kingma and Jimmy Ba. Adam: A method for stochastic optimization. CoRR, abs/1412.6980,
2015.
[39] James N Kirkpatrick, Razvan Pascanu, Neil C. Rabinowitz, Joel Veness, and et. al. Overcoming catastrophic
forgetting in neural networks. Proceedings of the National Academy of Sciences of the United States of
America, 114 13:3521–3526, 2017.
[40] Soheil Kolouri, Nicholas Ketz, Xinyun Zou, Jeffrey Krichmar, and Praveen Pilly. Attention-based structural-
plasticity. arXiv preprint arXiv:1903.06070, 2019.
[41] Matthias Lange, Rahaf Aljundi, Marc Masana, Sarah Parisot, Xu Jia, Ale Leonardis, Gregory G. Slabaugh,
and Tinne Tuytelaars. Continual learning: A comparative study on how to defy forgetting in classiﬁcation
tasks. ArXiv, abs/1909.08383, 2019.
[42] Sang-Woo Lee, Jin-Hwa Kim, Jaehyun Jun, Jung-Woo Ha, and Byoung-Tak Zhang. Overcoming catas-
trophic forgetting by incremental moment matching. In Neural information processing systems, pages
4652–4662, 2017.
[43] Aitor Lewkowycz, Yasaman Bahri, Ethan Dyer, Jascha Sohl-Dickstein, and Guy Gur-Ari. The large
learning rate phase of deep learning: the catapult mechanism. arXiv preprint arXiv:2003.02218, 2020.
[44] Xilai Li, Yingbo Zhou, Tianfu Wu, Richard Socher, and Caiming Xiong. Learn to grow: A continual
structure learning framework for overcoming catastrophic forgetting. arXiv preprint arXiv:1904.00310,
2019.
[45] Zhongyuan Li and Sanjeev Arora. An exponential learning rate schedule for deep learning. ArXiv,
abs/1910.07454, 2019.
[46] David Lopez-Paz and Marc’Aurelio Ranzato. Gradient episodic memory for continual learning. In
Advances in Neural Information Processing Systems, pages 6467–6476, 2017.
[47] Arun Mallya and Svetlana Lazebnik. Packnet: Adding multiple tasks to a single network by iterative
pruning. 2018 IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 7765–7773,
2017.
11
[48] Nicolas Y . Masse, Gregory D. Grant, and David J. Freedman. Alleviating catastrophic forgetting using
context-dependent gating and synaptic stabilization. Proceedings of the National Academy of Sciences of
the United States of America, 115 44, 2018.
[49] Dominic Masters and Carlo Luschi. Revisiting small batch training for deep neural networks. arXiv
preprint arXiv:1804.07612, 2018.
[50] Michael McCloskey and Neal J. Cohen. Catastrophic interference in connectionist networks: The sequential
learning problem. 1989.
[51] Martial Mermillod, Aurélia Bugaiska, and Patrick Bonin. The stability-plasticity dilemma: investigating
the continuum from catastrophic forgetting to age-limited learning effects. In Front. Psychol., 2013.
[52] Seyed Iman Mirzadeh, Mehrdad Farajtabar, and Hassan Ghasemzadeh. Dropout as an implicit gating
mechanism for continual learning. In The IEEE Conference on Computer Vision and Pattern Recognition
(CVPR) Workshops, 2020.
[53] Cuong V Nguyen, Yingzhen Li, Thang D Bui, and Richard E Turner. Variational continual learning. arXiv
preprint arXiv:1710.10628, 2017.
[54] Cuong V Nguyen, Alessandro Achille, Michael Lam, Tal Hassner, Vijay Mahadevan, and Stefano Soatto.
Toward understanding catastrophic forgetting in continual learning. arXiv preprint arXiv:1908.01091,
2019.
[55] Amir Gholami Michael Mahoney Joseph Gonzalez Noah Golmant, Zhewei Yao. pytorch-hessian-
eigentings: efﬁcient pytorch hessian eigendecomposition, October 2018. URL https://github.com/
noahgolmant/pytorch-hessian-eigenthings.
[56] German Ignacio Parisi, Ronald Kemker, Jose L. Part, Christopher Kanan, and Stefan Wermter. Continual
lifelong learning with neural networks: A review. 2018.
[57] Dushyant Rao, Francesco Visin, Andrei Rusu, Razvan Pascanu, Yee Whye Teh, and Raia Hadsell. Continual
unsupervised representation learning. In Advances in Neural Information Processing Systems, pages 7645–
7655, 2019.
[58] Sylvestre-Alvise Rebufﬁ, Alexander I Kolesnikov, Georg Sperl, and Christoph H. Lampert. icarl: Incre-
mental classiﬁer and representation learning. 2017 IEEE Conference on Computer Vision and Pattern
Recognition (CVPR), pages 5533–5542, 2016.
[59] Matthew Riemer, Ignacio Cases, Robert Ajemian, Miao Liu, Irina Rish, Yuhai Tu, and Gerald Tesauro.
Learning to learn without forgetting by maximizing transfer and minimizing interference. arXiv preprint
arXiv:1810.11910, 2018.
[60] Amanda Rios and Laurent Itti. Closed-loop gan for continual learning. arXiv preprint arXiv:1811.01146,
2018.
[61] Hippolyt Ritter, Aleksandar Botev, and David Barber. Online structured laplace approximations for
overcoming catastrophic forgetting. In Advances in Neural Information Processing Systems, pages 3738–
3748, 2018.
[62] Andrei A Rusu, Neil C Rabinowitz, Guillaume Desjardins, Hubert Soyer, James Kirkpatrick, Ko-
ray Kavukcuoglu, Razvan Pascanu, and Raia Hadsell. Progressive neural networks. arXiv preprint
arXiv:1606.04671, 2016.
[63] Andrew M Saxe, James L McClelland, and Surya Ganguli. Exact solutions to the nonlinear dynamics of
learning in deep linear neural networks. arXiv preprint arXiv:1312.6120, 2013.
[64] Jonathan Schwarz, Wojciech Czarnecki, Jelena Luketina, Agnieszka Grabska-Barwinska, Yee Whye Teh,
Razvan Pascanu, and Raia Hadsell. Progress & compress: A scalable framework for continual learning. In
International Conference on Machine Learning, pages 4535–4544, 2018.
[65] Hanul Shin, Jung Kwon Lee, Jaehong Kim, and Jiwon Kim. Continual learning with deep generative
replay. In Advances in Neural Information Processing Systems, pages 2990–2999, 2017.
[66] Samuel L. Smith, Pieter-Jan Kindermans, and Quoc V . Le. Don’t decay the learning rate, increase the
batch size. ArXiv, abs/1711.00489, 2017.
[67] Nitish Srivastava. Improving neural networks with dropout. 2013.
12
[68] Michalis K Titsias, Jonathan Schwarz, Alexander G de G Matthews, Razvan Pascanu, and Yee Whye Teh.
Functional regularisation for continual learning using gaussian processes.arXiv preprint arXiv:1901.11356,
2019.
[69] Mariya Toneva, Alessandro Sordoni, Remi Tachet des Combes, Adam Trischler, Yoshua Bengio, and
Geoffrey J Gordon. An empirical study of example forgetting during deep neural network learning. arXiv
preprint arXiv:1812.05159, 2018.
[70] Colin Wei, Sham M. Kakade, and Tengyu Ma. The implicit and explicit regularization effects of dropout.
volume abs/2002.12915, 2020.
[71] Junfeng Wen, Yanshuai Cao, and Ruitong Huang. Few-shot self reminder to overcome catastrophic
forgetting. arXiv preprint arXiv:1812.00543, 2018.
[72] Ashia C. Wilson, Rebecca Roelofs, Mitchell Stern, Nathan Srebro, and Benjamin Recht. The marginal
value of adaptive gradient methods in machine learning. ArXiv, abs/1705.08292, 2017.
[73] Zeke Xie, Issei Sato, and Masashi Sugiyama. A diffusion theory for deep learning dynamics: Stochastic
gradient descent escapes from sharp minima exponentially fast. arXiv preprint arXiv:2002.03495, 2020.
[74] Jaehong Yoon, Eunho Yang, Jungtae Lee, and Sung Ju Hwang. Lifelong learning with dynamically
expandable networks. In Sixth International Conference on Learning Representations. ICLR, 2018.
[75] Guanxiong Zeng, Yang Chen, Bo Cui, and Shan Yu. Continuous learning of context-dependent processing
in neural networks. arXiv preprint arXiv:1810.01256, 2018.
[76] Friedemann Zenke, Ben Poole, and Surya Ganguli. Continual learning through synaptic intelligence. In
Proceedings of the 34th International Conference on Machine Learning-Volume 70, pages 3987–3995.
JMLR, 2017.
[77] Guodong Zhang, Lala Li, Zachary Nado, James Martens, Sushant Sachdeva, George Dahl, Chris Shallue,
and Roger Grosse. Which algorithmic choices matter at which batch sizes? insights from a noisy quadratic
model. In NeurIPS 2019 : Thirty-third Conference on Neural Information Processing Systems , pages
8196–8207, 2019.
[78] Mengmi Zhang, Tao Wang, Joo Hwee Lim, and Jiashi Feng. Prototype reminding for continual learning.
arXiv preprint arXiv:1905.09447, 2019.
13
Supplementary material
In this document, we present the materials that were excluded or summarized due to space limitation
in the main text. It is organized as follows:
Appendix A extends our analysis in Section 3 of the main text regarding the forgetting in continual
learning.
Appendix B provides further information for our experimental setup and the hyper-parameters used
for each experiment. Note that, in addition to this document, we provide our code with scripts to
reproduce the results for each experiment.
Appendix C includes additional experiments and results. More speciﬁcally, it includes:
• Additional information about Figure 1 such as accuracy on all tasks.
• Extended version of Table 1 with detailed discussion.
• Additional results regarding the norm of parameters in our ﬁrst experiment (Section. 5.2)
• Additional results regarding the comparison of the ﬁrst task accuracy for algorithms in our
second experiment (Section. 5.3).
• A new experiment in Appendix C.5, where we apply the stability techniques for other
methods such as A-GEM and EWC. We demonstrate that these methods can enjoy a
performance boost if they use a stable training regime.
A Further analysis
In this section, we extend our analysis in Section 3 of the main paper.
Letw∗
1 andw∗
2 still be the optimal points for the tasks while ˆw1 and ˆw2 are the convergent or (near-)
optimum parameters after training has been ﬁnished for the ﬁrst and second task, sequentially. We
usually use Stochastic Gradient Descent (SGD) or its many variants to ﬁnd a low-error plateau for the
optimization procedure. We can deﬁne theforgetting (of the ﬁrst task) using the convergent point too:
F1 ≜L1( ˆw2)−L1( ˆw1). (9)
We can approximateL1( ˆw2) andL1( ˆw1) aroundw∗
1:
L1( ˆw1)≈L1(w∗
1) + ( ˆw1−w∗
1)⊤∇L1(w∗
1) + 1
2( ˆw1−w∗
1)⊤∇2L1(w∗
1)( ˆw1−w∗
1) (10)
≈L1(w∗
1) + 1
2( ˆw1−w∗
1)⊤∇2L1(w∗
1)( ˆw1−w∗
1), (11)
where,∇2L1(w∗
1) is the Hessian for lossL1 atw∗
1 and the last equality holds because the model is
assumed to converge to critical point or it had stopped in a plateau where gradient’s norm vanishes,
thus∇L1(w∗
1)≈ 0. Similarly,
L1( ˆw2)≈L1(w∗
1) + 1
2( ˆw2−w∗
1)⊤∇2L1(w∗
1)( ˆw2−w∗
1). (12)
Deﬁning∆w = ˆw2− ˆw1 as the relocation vector we compute the forgetting according to Eq. (9):
F1≈ 1
2( ˆw2−w∗
1)⊤∇2L1(w∗
1)( ˆw2−w∗
1)− 1
2( ˆw1−w∗
1)⊤∇2L1(w∗
1)( ˆw1−w∗
1) (13)
= 1
2(( ˆw2−w∗
1)− ( ˆw1−w∗
1)))∇2L1(w∗
1)(( ˆw2−w∗
1) + ( ˆw1−w∗
1))) (14)
≈ 1
2∆w⊤∇2L1(w∗
1)∆w, (15)
where in the last equality we used∥ ˆw1−w∗
1∥≪∥ ˆw2−w∗
1∥. Under the assumption that the critical
point is a minima (or the plateau we get stuck surrounding a minima), we know that the Hessian
needs to be positive semi-deﬁnite. We can use this property further to boundF1 as follows:
F1 =L1( ˆw2)−L1( ˆw1)≈ 1
2∆w⊤∇2L1(w∗
1)∆w≤ 1
2λmax
1 ∥∆w∥2, (16)
14
whereλmax
1 is the maximum eigenvalue of∇2L1(w∗
1). Fig. 5a shows how widerL1 (lowerλmax
1 )
leads to less forgetting.
Controlling the spectrum of the Hessian without controlling the norm of the displacement can not
ensure thatF1 is minimized.
Assume the algorithm has already converged to a plateau where gradient’s norm vanishes for L1
and stopped at ˆw1 and is about to optimize L2. The weights are updated according to η∇L2(w)
iteratively until a ﬁxed number of iterations, or a minimum (validation) loss, or minimum gradient
magnitude is achieved. We show that∥∆w∥ is related toλmax
2 (Refer to ﬁg. 5b for an illustration).
Using the triangle inequality we write:
∥∆w∥ =∥ ˆw2− ˆw1∥≥∥ w∗
2− ˆw1∥−∥ ˆw2−w∗
2∥. (17)
Since∥w∗
2− ˆw1∥ is constant we only need to bound∥ ˆw2−w∗
2∥. We examine two different conver-
gence criterion.
For the caseL2( ˆw2)−L2(w∗
2)≤ϵ is the convergence criterion, we write the second order Taylor
approximation ofL2 aroundw∗
2:
L2( ˆw2)−L2(w∗
2)≈ ( ˆw2−w∗
2)⊤∇L2(w∗
2) + 1
2( ˆw2−w∗
2)⊤∇2L2( ˆw2)( ˆw2−w∗
2). (18)
Again,∇L2(w∗
2) = 0 and the ﬁrst term in the R.H.S. is dismissed. Moreover the second term in
the R.H.S. can be upper bounded by 1
2λmax
2 ∥w∗
2− ˆw2∥2. Therefore, one can write the convergence
criterion as
1
2λmax
2 ∥w∗
2− ˆw2∥2≤ϵ =⇒∥w∗
2− ˆw2∥≤ 2√ϵ
λmax
2
. (19)
Combining the above with (17) we get:
∥∆w∥≥ C− 2√ϵ
λmax
2
, (20)
where,C =∥w∗
2− ˆw1∥ is constant. Therefore, by decreasingλmax
2 , the lower bound on the∥∆w∥
decreases and the near-optimumw∗
2 can be reached in a closer distance to w∗
1. Fig. 5b shows this
case.
For the case where∥∇L2∥ ( ˆw2)≤ ϵ is the convergence criterion we write the ﬁrst order Taylor
approximation of∇L2 aroundw∗
2:
∇L2( ˆw2)−∇L2(w∗
2)≈∇ 2L2(w∗
2)( ˆw2−w∗
2). (21)
Again,∇L2(w∗
2) = 0 and the second term in the L.H.S. is dismissed. Moreover, the R.H.S. can be
upper bounded byλmax
2 ∥w∗
2− ˆw2∥. Therefore, one can write the convergence criterion as
λmax
2 ∥w∗
2− ˆw2∥≤ ϵ =⇒∥w∗
2− ˆw2∥≤ ϵ
λmax
2
. (22)
Combining the above with (17) we get:
∥∆w∥≥ C− ϵ
λmax
2
, (23)
where,C =∥w∗
2− ˆw1∥ is constant. Therefore, by decreasingλmax
2 , the lower bound on the∥∆w∥
decreases and the near-optimum ˆw2 can be reached within a smaller distance from ˆw1.
In practice, we usually ﬁx the number of gradient updateη∇L2(w) iterations where the learning rate
and the gradient of the loss for task 2, play important roles. First, it’s already clear that the smaller
the learning rate, the higher the chance of ﬁnding ˆw2 close to ˆw1. More importantly, learning decay
helps with wider minima by allowing to start with a large learning rate and imposing an exploration
phase that increases the chance of ﬁnding a wider minima. Therefore, learning rate decay plays a
signiﬁcant role in reducing catastrophic forgetting.
Second, the magnitude of the update is proportional to∥∇L2(w)∥ where is lager for higher curvature
not only at the minima but in its neighborhood too. Look at Fig. 5b for a simplistic illustration where
we assume that the (near-)optimal points for the low and high curvature achieved lie very close to
each other. Again, we can intuitively see that the forgetting is correlated with the curvature around
the local minimas.
15
w∗
1 ˆ w1 ˆ w2 w∗
2
Parameter Space
Loss
F1
F′
1
∆w
L1(w) = λ1 (w − w∗
1)2
L′
1(w) = 2λ1 (w − w∗
1)2
L2(w) = λ2 (w − w∗
2)2
(a)
w∗
1 ˆ w2 ˆ w′
2 w∗
2
ϵ Loss
F1
∆w
F′
1
∆′w
L1(w) = λ1 (w − w∗
1)2
L2(w) = λ2 (w − w∗
2)2
L′
2(w) = 2λ2 (w − w∗
2)2 (b)
Figure 5: (a): For a ﬁxed∆w, the wider the curvature of the ﬁrst task, the less the forgetting. (b):
The wider the curvature of the second task, the smaller∥∆w∥.
B Experimental Setup Details
B.1 Discussion on our experiment design
We would like to note that one fundamental criterion we take into account in our experiments is to
facilitate the veriﬁcation of our results. We achieve this goal by:
1. Reporting the results on common continual learning datasets used in previous studies:
For instance, as mentioned in the main text, the majority of continual learning papers to
which we compare our results use Permuted MNIST, Rotated MNIST, and Split CIFAR-100
benchmarks. While we acknowledge the fact that continual learning literature can beneﬁt
from benchmarks in other domains beyond computer vision, we agree with the current trend
that CIFAR-100 with 20 sequential tasks is challenging enough for continual learning.
2. Using similar architectures with other studies: For our ﬁrst experiment, we used two-layer
MLP on MNIST datasets o 5 tasks. This architecture is used in [ 13, 70]. For the second
experiment on 20 tasks, the Resnet architecture described in the text, was used in [6, 8, 7].
The only change we apply to the architecture was to add dropout layers in residual blocks.
3. Providing metrics for accuracy and forgetting: We believe any continual learning work
should provide report both mentioned metrics. We also report these metrics, which are also
reported in [6, 7, 8].
4. Releasing the code. We include the code for our experiments in order to enable the reader
to replicate the experiments and reproduce the results with the reported hyper-parameters.
Besides the scripts, we provide the details regarding the installation and execution in the
“readme.md” document attached to the“code” folder.
B.2 Continual learning setup
In this section, we review our experimental setup (e.g., number of tasks, number of epochs per task).
In experiment 1 (Section 5.2), our goal was to elaborate the impact of training regime. Hence, we
found that ﬁve tasks and two benchmarks are sufﬁcient for our purpose. Each task in that experiment
had 5 training epochs.
In experiment 2 (Section 5.3), we aimed to demonstrate the performance of stable training regime,
and hence, we chose the setup that is similar to our baselines. We used 20 tasks where each task had
1 training epoch. This setup is used in several studies [6, 8, 7].
In the new experiment in Appendix C.5, the purpose is to show that the stability techniques can be
incorporated into other algorithms such as A-GEM, EWC, and ER-Reservoir. We use the rotation
MNIST with 20 tasks and 1 epoch per task.
Finally, We note that we have used Stochastic Gradient Descent (SGD) optimizer in all experiments,
and we have not employed any data augmentation technique or shufﬂing.
16
B.3 Hyperparameters in experiments
In this section, we report the hyper-parameters we used in our experiments. For other algorithms
(e.g., A-GEM, and EWC), we ensured that our hyper-parameters included the optimal values that
the original papers reported. We used grid search for each model to ﬁnd the best set of parameters
detailed below:
Parameters for experiment 1
B.3.1 Plastic (Naive)
• initial learning rate: [0.25, 0.1, 0.01, 0.001]
• batch size: 64
B.3.2 Stable
• initial learning rate: [0.25, 0.1, 0.01, 0.001]
• learning rate decay: [0.9, 0.75, 0.4, 0.25]
• batch size: [16, 64]
• dropout: [0.5, 0.25]
Parameters for experiment 2
B.3.3 Naive
• initial learning rate: [0.25, 0.1, 0.01 (MNIST, CIFAR-100), 0.001]
• batch size: 10
B.3.4 Stable
• initial learning rate: [0.25, 0.1 (MNIST, CIFAR-100), 0.01, 0.001]
• learning rate decay: [0.9, 0.85, 0.8]
• batch size: [10, 64]
• dropout: [0.5 (MNIST), 0.25 (CIFAR-100)]
B.3.5 EWC
• initial learning rate: [0.25, 0.1 (MNIST, CIFAR-100), 0.01, 0.001]
• batch size: 10
• λ (regularization): [1, 10 (MNIST, CIFAR-100), 100]
B.3.6 AGEM
• initial learning rate: [0.25, 0.1 (MNIST), 0.01 (CIFAR-100), 0.001]
• batch size: 10
B.3.7 ER
• initial learning rate: [0.25, 0.1 (MNIST), 0.01 (CIFAR-100), 0.001]
• batch size: 10
17
C Additional Results
C.1 Detailed accuracy of the networks in Figure 1
Figure 1 in the introduction (Section 1), compares the ﬁrst task accuracy between the naive SGD and
the stable SGD. Here, we provide the accuracy of all tasks for these two training regimes.
Although in the introduction section we did not introduce the "stable training" term, we note that
Network 1 (i.e., the stable network), suffers much less from the catastrophic forgetting of previous
tasks compared to Network 2 (i.e., the plastic network), thanks to the training regime, and at the cost
of a relatively small drop in the accuracy of the current task.
1 2 3 4 5
Tasks Learned
65
70
75
80
85
90
95
100Accuracy
Task 1
Task 2
Task 3
Task 4
Task 5
(a) Network 1 (Stable Network)
1 2 3 4 5
Tasks Learned
65
70
75
80
85
90
95
100Accuracy
Task 1
Task 2
Task 3
Task 4
Task 5 (b) Network 2 (Plastic Network)
Figure 6: Full results for the comparison of accuracy on all tasks for two networks in Figure 1 of the
introduction section.
C.2 Extended version of Table 1 in Section 3: disentangling the stability of different tasks
In this section, we aim to disentangle the role that stable training of the current task 1 plays against
stable training of task 2 in decreasing the catastrophic forgetting for task 1.
In table 3, we report the forgetting measure F1 for four different scenarios: training the ﬁrst task
(with/without) stability techniques and training the second task (with/without) these techniques,
respectively. The reported “Stable” networks in this table use dropout probability of 0.25, learning
rate decay of 0.4 and a small batch size of 16, while “Plastic” networks do not exploit the dropout
regularization and learning rate decay, and set the batch size to 256.
The reported mean and standard deviations are calculated for ﬁve different runs with different
random seeds. As expected, the case Stable/Stable is the best and Plastic/Plastic is the worst in
terms of forgetting. But the interesting observation is the huge difference between Stable/Plastic and
Plastic/Stable. This suggests, among other possible explanations, that the wideness of the current task
is more important than the wideness of the subsequent tasks for the goal of reducing the forgetting.
Table 3: Disentanglment of forgetting on Permuted MNIST.
Task 1 Task 2 Forgetting
(F1) λmax
1 ∥∆w∥
Stable Stable 1.61 ± (0.48) 2.19 ± (0.12) 73.1 ± (1.23)
Stable Plastic 4.77 ± (1.72) 2.21 ± (0.18) 174.4 ± (7.66)
Plastic Stable 12.45 ± (1.58) 7.72 ± (0.19) 74.7 ± (2.63)
Plastic Plastic 19.37 ± (1.79) 7.73 ± (0.22) 178.4 ± (8.58)
C.3 Additional result for experiment 1: comparing norms of weights
In section 4.2, we discussed that dropout pushes down the norm of the weights by regularizing the
activations. To support this argument, in Figure 7 we compare the norm of the weights for stable
and plastic networks in experiment 1. For the stable network the norm of the optimal solutions after
training each task is smaller and this might be the reason for smaller displacement in the sequential
18
optimizations for tasks. Further analysis and theoretical justiﬁcation of this phenomena is beyond the
scope of the current paper and is left as an interesting future work.
1 2 3 4 5
Tasks
15
20
25∥w∥
Stable
Plastic
(a) Permuted MNIST
1 2 3 4 5
Tasks
15
20
25∥w∥
Stable
Plastic (b) Rotation MNIST
Figure 7: Comparing the norm of parameters for networks in experiment 1
C.4 Additional result for experiment 2: comparison of the ﬁrst task accuracy
In Section 5.3, we provided the plots for the evolution of average accuracy during the continual
learning experience. Here, we measure the validation accuracy of the ﬁrst task during the learning
experience with 20 tasks in Figure 8. The ﬁgure reveals that the stable network remembers the ﬁrst
task much better than other methods.
1 5 10 15 20
Tasks
20
40
60
80
90
100Accuracy
STABLE-T1
AGEM-T1
ER-T1
EWC-T1
Naive-T1
(a) Permuted MNIST
1 5 10 15 20
Tasks
20
40
60
80
100Accuracy
STABLE-T1
AGEM-T1
ER-T1
EWC-T1
Naive-T1 (b) Rotated MNIST
1 5 10 15 20
Tasks
20
30
40
45
50
60
70Accuracy
STABLE-T1
AGEM-T1
ER-T1
EWC-T1
Naive-T1 (c) Split CIFAR-100
Figure 8: Evolution of the ﬁrst task accuracy
C.5 New experiment: stabilizing other methods
One important question that deserves further investigation is “Can other methods beneﬁt from the
stable training regime?”. In this section, we show that the answer is yes.
For the rotation MNIST dataset with 20 tasks, we use similar architecture and hyper-parameters for
SGD, EWC, A-GEM, and ER-Reservoir as described in Appendix B. To make these models stable,
we add dropout (with the dropout probability 0.25), keep the batch size small, and use a decay factor
of 0.65 to decrease the learning rate at the end of each task.
Table 4 shows that by merely stabilizing the training regime, we can improve the average accuracy of
EWC, A-GEM, and ER-Reservoir by 12.9%, 15.8% and 9%, respectively. Besides, Figure 9 shows
the evolution of the average accuracy throughout the learning experience. As expected, the episodic
memory in stable A-GEM and stable ER-Reservoir helps these methods to outperform Stable SGD,
which does not use any memory. However, as noted before, stable SGD outperforms these complex
methods in their original form when they do not employ stabilization techniques.
19
Table 4: Comparison of the average accu-
racy and forgetting
Method Average
Accuracy Forgetting
SGD 46.3 ( ±1.37) 0.52 (±0.01)
Stable SGD 70.8 ( ±0.78) 0.10 (±0.02)
EWC 48.5 ( ±1.24) 0.48 (±0.01)
Stable EWC 61.4 ( ±1.15) 0.30 (±0.01)
AGEM 55.3 ( ±1.47) 0.42 (±0.01)
Stable AGEM 71.1 (±1.06) 0.13 (±0.01)
ER-Reservoir 69.2 ( ±1.10) 0.21 (±0.01)
Stable ER-Reservoir 78.2 (±0.74) 0.09 (±0.01)
1 5 10 15 20
Tasks
50
60
70
80
90
100Average Accuracy
STABLE SGD
SGD
STABLE ER
ER
STABLE AGEM
AGEM
STABLE EWC
EWC
Figure 9: Evolution of average accuracy
20